//-------------------------------------------------------------------------------------------------------------
// CROSS-PITCHER USING WAV
// This program emulates what we did in fcross, but this time we are not going to use autogenerated 
// sinusoidals but instead the wav samples 
//-------------------------------------------------------------------------------------------------------------
#include "autil.h"
#include "fftw3.h"
#include "pitch.h"
#include "pnetlib.h"
#include "ptask_time.h"
#include "mutils.h"
#include "wav.h"

#define SAMPLERATE			44100
#define FRAMES				2205
#define CHANNELS			1 		// must work in this case too
#define MIN_SCALE			3
#define MAX_SCALE			6
#define WAV_NAME_SIZE		25

#define CAPTUR_PERIOD		50 		// ms
#define POWER_THRESH_WAV	0.0001	// wavs are mainly normalized and then very small
#define POWER_THRESH_ALSA	0.003

char* norm_file = "logs/fcross_wav_norm.txt";
char* fftw_file = "logs/fcross_wav_fftw.txt";

// add accepted chunks read from an openened wav file to a given example list
int insert_wav (struct example** set, int* set_size, SNDFILE* file, alsa_param_t* apar, int pitch)
{
	float**			chunk_buffer;		 // array of arrays -> the example samples
	float 			label[NPITCHES3]; 	// the example label, determined by the parameter 'pitch'
	int 			accepted = 0, discarded = 0;
	int 			i, j, f;
	int 			read_frames;
		
	// remember that aparam->frames contains the whole frames contained into the file
	const int 		totchunks = apar->frames / FRAMES;
	float 			chunk_power [totchunks];
	
	dbg_printf("We get %d chunks with a surplus of %d\n", totchunks, (apar->frames%FRAMES));

	chunk_buffer = (float**) malloc (sizeof(float*) * totchunks);
	for (i=0; i<totchunks; i++)
	{
		chunk_buffer[i] = (float*) malloc (FRAMES * apar->channels * sizeof(float));
		read_frames = read_wavchunk_float (file, chunk_buffer[i], FRAMES, apar->channels);
		if (read_frames <= 0)
		{
			fprintf(stderr, "Frames returned: %d\n", read_frames);
			break;
		}
		chunk_power[i] = euler_trapezoid_float(chunk_buffer[i], (1.0/SAMPLERATE), FRAMES);
	}
	// now we have an array of chunks and relative powerness saved
	
	// cycle on the chunk buffer to select those that have sufficient power. Insert those into list
	// Remeber that for each channel we add a new sample
	for (i=0; i<totchunks; i++)
	{
		if (chunk_power[i] > POWER_THRESH_WAV)
		{
			accepted++;
			// label is ok
			for (f=0; f<NPITCHES3; f++)
				label[f] = 0.0;
			label[pitch] = 1.0;
				
			if (apar->channels > 1)
			{
				float tmp_buf[(const int)FRAMES];
				for (j=0; j<apar->channels; j++)
					for (f=0; f<FRAMES; f++)
						tmp_buf[f] = chunk_buffer[i][f*apar->channels+j];
				*set = insert_example (*set, tmp_buf, FRAMES, label, NPITCHES3);
			}
			else
				*set = insert_example (*set, chunk_buffer[i], FRAMES, label, NPITCHES3);
		}
		else
			discarded++;
/*		dbg_printf("Power of chunk %d is: %f\n", i, chunk_power[i]);*/
	}
	dbg_printf("Insert new chunks: %d accepted for pitch %s (%d).", accepted, which_pitch3(pitch), pitch);
	dbg_printf("Discarded chunks: %d\n", discarded);
		
	// free memory
	for (i=0; i<totchunks; i++)
		free(chunk_buffer[i]);
	free(chunk_buffer);
		
	return accepted;
}


// thread utility
pthread_t				capturer;			
struct timespec 		t_cap;	// structure for monitoring activation of task

// task argument used to pass objects to a thread
struct task_parameter
{
	struct example* set;
	int 			size;
	int 			samp_size; // NUM_INPUTS
};

// normalize an array of real numbers
void normalize (float array[], int dim)
{
	float 	min, max;
	int 	i;
	// search max and min
	min = array[0];
	max = array[0];
	for (i=0; i<dim; i++)
	{
		if (array[i] < min)
			min = array[i];
		if (array[i] > max)
			max = array[i];
	}
	// apply formula for all samples
	for (i=0; i<dim; i++)
		array[i] = (array[i] - min) / (max - min);

}

//--------------------------------------------------------------------------------------------------------
// THREADS
//--------------------------------------------------------------------------------------------------------
void *capturer_task(void* arg) 
{
	printf("[CAPTUR] Now active\n");
	
	alsa_param_t			a_param;
	int 					err, i, j;
	double*					in;
	fftw_complex*			out;
	fftw_plan 				p;
	struct task_parameter*	t_param;
	float 					power;
	float 					tmp_buf[FRAMES*CHANNELS];

	// get reference_set and its size through a param 
	t_param = (struct task_parameter*) arg;
	assert (t_param->set != NULL);
	// open alsa device for capturing
	capture_handle = alsa_open("default", MODE_CAPT);
	if (capture_handle == NULL)
	{
		fprintf(stderr, "[CAPTUR] capture_handle is NULL\n");
		pthread_exit(NULL);
	}
		
	// we want to acquire numbers that can be easily normalized
	alsa_param_init(&a_param); 				
	a_param.format = SND_PCM_FORMAT_FLOAT;		
	a_param.frames = FRAMES;
	a_param.channels = CHANNELS;
	alsa_param_print(&a_param);
	// harware parameter configuration and freeing
	alsa_hw_param_config(capture_handle, &a_param);
	// prepare
	if ((err = snd_pcm_prepare (capture_handle)) < 0)
	{
		fprintf(stderr, "[CAPTUR] Cannot prepare audio interface for use (%s)\n", snd_strerror(err));
		pthread_exit(NULL);
	}
	printf("[CAPTUR] Ready for capture...\n");
	
	// according to what just defined, prepare buffers for fourier trasform. We tranform one channel 
	// at a time, so we could get more than one pitch over different channels!
	in 	= (double*) fftw_malloc (sizeof(double) * FRAMES);
	out = (fftw_complex*) fftw_malloc (sizeof(fftw_complex) * FRAMES);
    p 	= fftw_plan_dft_r2c_1d(FRAMES, in, out, FFTW_ESTIMATE);
	
	// prepare the buffer that resembles what we want to capture
	do
	{
		if ((err = alsa_capture_float(capture_handle, tmp_buf, &a_param)) < 0)
		{
			if (xrun_recovery(capture_handle, err, CAPTUR_PERIOD) < 0)
			{
				fprintf(stderr, "\n[CAPTUR] No buffer correctly allocated for capturing\n");
				pthread_exit(NULL);
			}
			// else proceed
		}
		
		// check the power 
		if ((power = euler_trapezoid_float (tmp_buf, 1.0/SAMPLERATE, FRAMES)) >= POWER_THRESH_ALSA)
		{
			// normalize what we got
			normalize (tmp_buf, FRAMES*CHANNELS);
			
			// DEBUG *** write it on a file!!
/*			FILE* ff = fopen("logs/capturer_norm.txt", "a+"); assert(ff!=NULL);*/
/*			for (i=0; i<FRAMES; i++)*/
/*				fprintf(ff, "%d,%f\n", i,tmp_buf[i*CHANNELS]);*/
/*			fclose(ff);*/
			
			// do the fft
			for (j=0; j<CHANNELS; j++)	
			{
				for (i=0; i<FRAMES; i++)
					in[i] = (double) tmp_buf[i*CHANNELS + j];
				fftw_execute(p);
				
				// DEBUG *** write it on a file!!
				FILE* ff = fopen("logs/capturer_fftw.txt", "a+"); assert(ff!=NULL);
				for (i=0; i<t_param->samp_size; i++)
				{
					float module = sqrt(pow((float)out[i][0],2) + pow((float)out[i][1],2));
					fprintf(ff, "%d,%f\n", i,module);
				}
				fclose(ff);
		
				// for each of the references, do the avg squared error with the samples and out:
				// The minimum error let us save the relative label
				float 	avg_error = 0;
				float	min_error = RAND_MAX;
				int		min_pitch = PTNONDEF;
				int 	k=0;
				min_error = RAND_MAX; // enormous number
				for (struct example* list=t_param->set; list!=NULL; list=list->next)
				{
					assert(list->ns == t_param->samp_size);
					avg_error = 0;
					for (i=0; i<list->ns; i++)
					{
						float module = sqrt(pow((float)out[i][0],2) + pow((float)out[i][1],2));
						avg_error += pow((module - list->samples[i]), 2);
					}
					avg_error = sqrt(avg_error/list->ns);
					#ifdef __PNET_DEBUG__
					dbg_printf("Sample %d avg_err: %f; lab [", k, avg_error);
					for (i=0; i<NPITCHES3; i++)
						dbg_printf(" %d ", (int)list->label[i]);
					dbg_printf("]\n");
					#endif
					if (avg_error < min_error)
					{
						min_error = avg_error;
						for (i=0; i<NPITCHES3; i++)
							if (list->label[i] == 1.0)
								min_pitch = i;
/*						assert(i<NPITCHES3);*/
/*						min_pitch = i;*/
					}
					k++;
				}
				dbg_printf("avg err: %f, min avg: %f, min_pitch: %d\n", avg_error, min_error, min_pitch);
				if (CHANNELS > 1)
					printf("On channel %d pitch is %s\n", j, which_pitch3(min_pitch));
				else
					printf("I suppose you're playing pitch %s\n", which_pitch3(min_pitch));
			} 
			dbg_printf("\n");
		}
		else
		{
			printf("I don't hear anything... :(\r");
			fflush(stdout);
		}
		wait_for_period(&t_cap, CAPTUR_PERIOD);
	} while (1);
	
	printf("[CAPTUR] Thread is exiting...\n");
	// delete everything
	fftw_destroy_plan(p);
	fftw_free(in); fftw_free(out);
	pthread_exit(NULL);
}



//--------------------------------------------------------------------------------------------------------
// MAIN
//--------------------------------------------------------------------------------------------------------
int main() 
{
	printf("[MAIN] Setting up program...\n");

	// variables
	struct example* 		initial_set = NULL;				// set to be normalized: half is passed to reference
	struct example* 		reference_set = NULL;
	const int		 		NUM_INPUTS = (FRAMES/2) + 1;	// effective samples that match with out
	float					refsamp [NUM_INPUTS];
	int 					ini_size = 0;
	int 					ref_size = 0;
	char 					filename [WAV_NAME_SIZE];
	SNDFILE*				wav_file = NULL;
	SF_INFO					wav_info;
	alsa_param_t			wav_params;
	int 					f, s, i;
	double*					in;
	fftw_complex*			out;
	fftw_plan				p;	
	struct task_parameter 	passed_param;
	int 					err;
	
	
	// prepare in, out and plan: notice we see a channel at a time
	in  = (double*) fftw_malloc (sizeof(double) * FRAMES);
	out = (fftw_complex*) fftw_malloc (sizeof(fftw_complex) * FRAMES);
	p 	= fftw_plan_dft_r2c_1d(FRAMES, in, out, FFTW_ESTIMATE);
	
	//---------------------------------------------------------------------------
	// FOREACH FILE 1) read a wav 2) check power 3) add to training set
	//   Create a function that given a file descriptor reads its chunks
	//   and adds them to a given list -> chunk power ecc are managed inside
	//---------------------------------------------------------------------------
	for (f=0; f<NPITCHES; f++) // pitches (from C to B)
	{
		for (s=MIN_SCALE; s<MAX_SCALE; s++) // octave from 3 to 5
		{
			sprintf(filename, "wav_32f/%s%dvH.wav", which_pitch(f), s);
			dbg_printf("Filename now is: %s\n", filename);
	
			// open wav
			wav_file = open_wav (filename, &wav_info, &wav_params);
			if (wav_file == NULL)
			{ 
				fprintf(stderr, "Error while opening file %s\n", filename);
				exit(EXIT_FAILURE);
			}
			// check format is correct -> files with wrong formats are reported
			if (wav_params.format != SND_PCM_FORMAT_FLOAT)
			{
				dbg_printf("Warning: %s is not SND_PCM_FORMAT_FLOAT\n", filename);
				close_wav(wav_file);
				continue;
			}
			// create buffer and read from wav, accepting only sufficiently "powered" signals
			ini_size += insert_wav (&initial_set, &ini_size, wav_file, &wav_params, (s-MIN_SCALE)*NPITCHES + f);
			// close wav
			close_wav(wav_file);
		}
	}
/*	goto exit;*/
	
	// normalization of this first set
	normalize_examples(initial_set, ini_size);
	printf("We normalized %d valid sinusoidals over %d channels (size %d)\n", ini_size, CHANNELS, FRAMES);
	
	// fft done as in fcross.c
	for (struct example* list=initial_set; list!=NULL; list=list->next)
	{
		// initialize in, then execute plan
		for (i=0; i<list->ns; i++)
			in[i] = list->samples[i];
		fftw_execute(p);
		// transfer informations into the example: we take the module of the frequency complex
		for (i=0; i<NUM_INPUTS; i++)
			refsamp[i] = sqrt(pow(out[i][0],2) + pow(out[i][1],2));
		#ifdef __PNET_DEBUG__
		dbg_printf("Label [");
		for (i=0; i<NPITCHES3; i++)
			dbg_printf(" %d ", (int)list->label[i]);
		dbg_printf("]\n");
		#endif
		reference_set = insert_example (reference_set, refsamp, NUM_INPUTS, list->label, NPITCHES3);
		ref_size++;
	}
	printf("The reference set has %d valid ffts (size %d)\n", ref_size, NUM_INPUTS);	

	#ifdef __PNET_DEBUG__	
	// let's plot both, so we can check the correctness: take the first
	FILE * f1 = fopen(norm_file, "a+"); assert(f1!=NULL);
	FILE * f2 = fopen(fftw_file, "a+"); assert(f2!=NULL);
	printf("Printing sine (element of initial_set) and fft (correspondent on reference_set) ...\n");
	for (i=0; i<FRAMES; i++)
		fprintf(f1, "%d,%f\n", i, initial_set->samples[i]);
	for (i=0; i<NUM_INPUTS; i++)		
		fprintf(f2, "%d,%f\n", i, reference_set->samples[i]);
	fclose(f1); fclose(f2);
	#endif

	//---------------------------------------------------------------------------------------------------
	// ok, now we start sampling as we didi into pitcher. For each sampled chunk of FRAMES samples and 
	// CHANNELS channels, we normalize as before and we compare the fft signals using average squared 
	// error. The index with minimum error is the one we want, so we get the label.
	// We delegate this work to a periodic thread
	//---------------------------------------------------------------------------------------------------	
	// set capturer period
	set_period(&t_cap, CAPTUR_PERIOD);
	// set the parameter to pass
	passed_param.set  = reference_set;
	passed_param.size = ref_size;
	passed_param.samp_size = NUM_INPUTS;
	// crate and launch both threads
	if ((err = pthread_create(&capturer, NULL, capturer_task, (void*) &passed_param)) < 0) 
	{
		fprintf(stderr, "[MAIN] Cannot create capturer thread: %s\n", strerror(err));
		exit(EXIT_FAILURE);
	}
	// wait for the end
	pthread_join(capturer, NULL);
	
/*	exit:*/
	printf("[MAIN] Thread termined. Exiting...\n");
	
	// destroy all
	delete_all_examples(reference_set);
	delete_all_examples(initial_set);
	fftw_destroy_plan(p);
	fftw_free(in); fftw_free(out);
	return 0;	
}
